# 并行算法实验一     实验报告
本实验结果均为实际运行结果及其分析。程序运行在OSX 10.11.2操作系统上。
### EX1:运行例 1,观察结果,分析结果的成因。 
_test\_1运行结果如图所示_
![]()
**现象：**其中前三行先出现，1秒后最后一行出现。
**成因：**在进程中fork出了3个子进程，各自输出了PID，PPID后结束了进程，由于是由父进程fork来的，所以可以观察到他们的父进程都是同一个，即670
### EX2:考虑在例 1 中,sleep 函数的作用?如果将 sleep 函数去掉,程序运行结果是什么, 并分析一下成因? 
_test\_1NoSleep运行结果如图所示_

![]()
**现象：**有时出现顺序和实验一一致的结果，有时出现如图所示的结果。
**成因：**sleep函数保证了子进程在输出时的父进程是原先的父进程，而不是被回收后的父进程（系统）。去掉sleep函数后，在进程中fork进程。在输出启动时的父进程若存在，则父进程为该进程。若这时父进程已经结束，则进程被托管，此时父进程为1号进程，即系统。
### EX3:运行例 2,,观察结果,分析结果的成因。
_test\_2运行结果如图所示_
![]()
  
**现象：**如图所示，执行了当前目录下的hello程序。
**成因：**父进程fork出一个子进程，并等待子进程终止。子进程完成调用当前目录下的hello程序。hello程序是一个该程序外的独立程序。
### EX4:如果将例 2 中“if (execl("./hello","hello",NULL) \< 0)”代码改成“if (execl("/bin/ls", "ls", "-l", NULL) \< 0)” ,程序运行结果是什么。如果不用 exec 方式,而是自己编写一段代码,观察一下运行结果。考虑 wait 的作用。 
test\_2运行结果如图所示
![]()

**现象：**如图所示，显示了当前目录下的信息，即ls选项（实验中加入了-h选项）

### EX5:自己编写一个程序,用循环语句实现父进程创建子进程 1,子进程 1 又创建另一个子进程 2,依次这样下去,一直创建到子进程 3。然后在屏幕上输出 pid、ppid 信息。 
test\_3运行结果如图所示
![test\\\_3运行结果如图所示]()

代码情况如图所示：
![]()












